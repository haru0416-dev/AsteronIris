# ── Onboard: Banner & Steps ──────────────────────────────────────
onboard:
  banner:
    art: |
      ===============================================

        A S T E R O N I R I S

        Secure by default. Extensible by design. Built in Rust.

      ===============================================
    welcome: "Welcome to AsteronIris — a secure, extensible AI assistant."
    subtitle: "This wizard will configure your agent in under 60 seconds."
  step:
    language: "Language"
    workspace: "Workspace Setup"
    provider: "AI Provider & API Key"
    channels: "Channels (How You Talk to AsteronIris)"
    tunnel: "Tunnel (Expose to Internet)"
    tool_mode: "Tool Mode & Security"
    memory: "Memory Configuration"
    context: "Project Context (Personalize Your Agent)"
    scaffold: "Workspace Files"
  language:
    select_prompt: "Select language"

  repair:
    title: "Channels Repair — update channel tokens and allowlists only"
    saved: "Channel config saved: %{path}"

  # ── Step 1: Workspace ──
  workspace:
    default_location: "Default location: %{path}"
    use_default: "Use default workspace location?"
    custom_hint: "Custom location selected. Press Enter to edit path."
    enter_path: "Enter workspace path"
    confirm: "Workspace: %{path}"

  # ── Step 2: Provider ──
  provider:
    select_category: "Select provider category"
    tier_recommended: "Recommended (OpenRouter, Venice, Anthropic, OpenAI, Gemini)"
    tier_fast: "Fast inference (Groq, Fireworks, Together AI)"
    tier_gateway: "Gateway / proxy (Vercel AI, Cloudflare AI, Amazon Bedrock)"
    tier_specialized: "Specialized (Moonshot/Kimi, GLM/Zhipu, MiniMax, Qianfan, Z.AI, Synthetic, OpenCode Zen, Cohere)"
    tier_local: "Local / private (Ollama — no API key needed)"
    tier_custom: "Custom — bring your own OpenAI-compatible API"
    custom_title: "Custom Provider Setup"
    custom_subtitle: "any OpenAI-compatible API"
    custom_desc: "AsteronIris works with ANY API that speaks the OpenAI chat completions format."
    custom_examples: "Examples: LiteLLM, LocalAI, vLLM, text-generation-webui, LM Studio, etc."
    base_url_prompt: "API base URL (e.g. http://localhost:1234 or https://my-api.com)"
    api_key_prompt: "API key (or Enter to skip if not needed)"
    model_prompt: "Model name (e.g. llama3, gpt-4o, mistral)"
    select_provider: "Select your AI provider"
    ollama_no_key: "Ollama runs locally — no API key needed!"
    gemini_cli_detected: "Gemini CLI credentials detected! You can skip the API key."
    gemini_cli_reuse: "AsteronIris will reuse your existing Gemini CLI authentication."
    gemini_use_cli: "Use existing Gemini CLI authentication?"
    gemini_using_cli: "Using Gemini CLI OAuth tokens"
    gemini_api_key_url: "Get your API key at: https://aistudio.google.com/app/apikey"
    gemini_api_key_prompt: "Paste your Gemini API key"
    gemini_api_key_skip_prompt: "Paste your Gemini API key (or press Enter to skip)"
    gemini_cli_hint: "Or run `gemini` CLI to authenticate (tokens will be reused)."
    gemini_env_detected: "GEMINI_API_KEY environment variable detected!"
    api_key_url: "Get your API key at: %{url}"
    api_key_later: "You can also set it later via env var or config file."
    paste_key: "Paste your API key (or press Enter to skip)"
    key_skipped: "Skipped. Set %{env_var} or edit config.toml later."
    auth_method_prompt: "Choose authentication method"
    auth_method_api_key: "API key"
    auth_method_oauth: "OAuth via provider CLI (OpenAI Codex / Claude)"
    oauth_import_start: "Starting OAuth login flow in your provider CLI..."
    oauth_import_success: "OAuth import succeeded (source: %{source})"
    oauth_import_failed: "OAuth import failed (%{error}). Falling back to API key input."
    oauth_import_unavailable: "OAuth import is unavailable for this provider. Falling back to API key input."
    select_model: "Select your default model"
    confirm: "Provider: %{provider} | Model: %{model}"

  # ── Step 3: Channels ──
  channels:
    intro: "Channels let you talk to AsteronIris from anywhere."
    cli_always: "CLI is always available. Connect more channels now."
    select_prompt: "Connect a channel (or Done to continue)"
    done: "Done — finish setup"
    connected: "connected"
    configured: "configured"
    connect_bot: "connect your bot"
    skipped: "Skipped"
    testing: "Testing connection..."
    test_success: "Connected as %{name}"
    test_fail: "Connection failed — check your token and try again"
    summary: "Channels: %{channels}"
    # per-channel labels
    telegram: "Telegram"
    discord: "Discord"
    slack: "Slack"
    imessage: "iMessage"
    matrix: "Matrix"
    whatsapp: "WhatsApp"
    irc: "IRC"
    webhook: "Webhook"
    email: "Email"
    # Telegram
    telegram_subtitle: "talk to AsteronIris from Telegram"
    telegram_setup: "Telegram Setup"
    telegram_step1: "1. Open Telegram and message @BotFather"
    telegram_step2: "2. Send /newbot and follow the prompts"
    telegram_step3: "3. Copy the bot token and paste it below"
    telegram_token_prompt: "Bot token (from @BotFather)"
    telegram_allowlist_hint: "Allowlist your own Telegram identity first (recommended for secure + fast setup)."
    telegram_allowlist_format: "Use your @username without '@' (example: argenis), or your numeric Telegram user ID."
    telegram_allowlist_star: "Use '*' only for temporary open testing."
    telegram_users_prompt: "Allowed Telegram identities (comma-separated: username without '@' and/or numeric user ID, '*' for all)"
    telegram_no_users: "No users allowlisted — Telegram inbound messages will be denied until you add your username/user ID or '*'."
    # Discord
    discord_subtitle: "talk to AsteronIris from Discord"
    discord_setup: "Discord Setup"
    discord_step1: "1. Go to https://discord.com/developers/applications"
    discord_step2: "2. Create a New Application → Bot → Copy token"
    discord_step3: "3. Enable MESSAGE CONTENT intent under Bot settings"
    discord_step4: "4. Invite bot to your server with messages permission"
    discord_token_prompt: "Bot token"
    discord_guild_prompt: "Server (guild) ID (optional, Enter to skip)"
    discord_allowlist_hint: "Allowlist your own Discord user ID first (recommended)."
    discord_allowlist_format: "Get it in Discord: Settings -> Advanced -> Developer Mode (ON), then right-click your profile -> Copy User ID."
    discord_allowlist_star: "Use '*' only for temporary open testing."
    discord_users_prompt: "Allowed Discord user IDs (comma-separated, recommended: your own ID, '*' for all)"
    discord_no_users: "No users allowlisted — Discord inbound messages will be denied until you add IDs or '*'."
    # Slack
    slack_subtitle: "talk to AsteronIris from Slack"
    slack_setup: "Slack Setup"
    slack_step1: "1. Go to https://api.slack.com/apps → Create New App"
    slack_step2: "2. Add Bot Token Scopes: chat:write, channels:history"
    slack_step3: "3. Install to workspace and copy the Bot Token"
    slack_token_prompt: "Bot token (xoxb-...)"
    slack_workspace_connected: "Connected to workspace: %{team}"
    slack_error: "Slack error: %{error}"
    slack_app_token_prompt: "App token (xapp-..., optional, Enter to skip)"
    slack_channel_prompt: "Default channel ID (optional, Enter to skip)"
    slack_allowlist_hint: "Allowlist your own Slack member ID first (recommended)."
    slack_allowlist_format: "Member IDs usually start with 'U' (open your Slack profile -> More -> Copy member ID)."
    slack_allowlist_star: "Use '*' only for temporary open testing."
    slack_users_prompt: "Allowed Slack user IDs (comma-separated, recommended: your own member ID, '*' for all)"
    slack_no_users: "No users allowlisted — Slack inbound messages will be denied until you add IDs or '*'."
    # iMessage
    imessage_subtitle: "macOS only, reads from Messages.app"
    imessage_setup: "iMessage Setup"
    imessage_macos_only: "iMessage is only available on macOS."
    imessage_desc: "AsteronIris reads your iMessage database and replies via AppleScript."
    imessage_disk_access: "You need to grant Full Disk Access to your terminal in System Settings."
    imessage_contacts_prompt: "Allowed contacts (comma-separated phone/email, or * for all)"
    imessage_confirm: "iMessage configured (contacts: %{contacts})"
    # Matrix
    matrix_subtitle: "self-hosted, federated chat"
    matrix_setup: "Matrix Setup"
    matrix_desc: "You need a Matrix account and an access token."
    matrix_token_hint: "Get a token via Element → Settings → Help & About → Access Token."
    matrix_homeserver_prompt: "Homeserver URL (e.g. https://matrix.org)"
    matrix_token_prompt: "Access token"
    matrix_token_required: "Skipped — token required"
    matrix_test_fail: "Connection failed — check homeserver URL and token"
    matrix_room_prompt: "Room ID (e.g. !abc123:matrix.org)"
    matrix_users_prompt: "Allowed users (comma-separated @user:server, or * for all)"
    # WhatsApp
    whatsapp_subtitle: "Business Cloud API"
    whatsapp_setup: "WhatsApp Setup"
    whatsapp_step1: "1. Go to developers.facebook.com and create a WhatsApp app"
    whatsapp_step2: "2. Add the WhatsApp product and get your phone number ID"
    whatsapp_step3: "3. Generate a temporary access token (System User)"
    whatsapp_step4: "4. Configure webhook URL to: https://your-domain/whatsapp"
    whatsapp_token_prompt: "Access token (from Meta Developers)"
    whatsapp_phone_prompt: "Phone number ID (from WhatsApp app settings)"
    whatsapp_phone_required: "Skipped — phone number ID required"
    whatsapp_verify_prompt: "Webhook verify token (create your own)"
    whatsapp_test_success: "Connected to WhatsApp API"
    whatsapp_test_fail: "Connection failed — check access token and phone number ID"
    whatsapp_numbers_prompt: "Allowed phone numbers (comma-separated +1234567890, or * for all)"
    # IRC
    irc_subtitle: "IRC over TLS"
    irc_setup: "IRC Setup"
    irc_desc: "IRC connects over TLS to any IRC server"
    irc_sasl: "Supports SASL PLAIN and NickServ authentication"
    irc_server_prompt: "IRC server (hostname)"
    irc_port_prompt: "Port"
    irc_port_invalid: "Invalid port, using 6697"
    irc_nick_prompt: "Bot nickname"
    irc_nick_required: "Skipped — nickname required"
    irc_channels_prompt: "Channels to join (comma-separated: #channel1,#channel2)"
    irc_allowlist_hint: "Allowlist nicknames that can interact with the bot (case-insensitive)."
    irc_allowlist_star: "Use '*' to allow anyone (not recommended for production)."
    irc_users_prompt: "Allowed nicknames (comma-separated, or * for all)"
    irc_empty_allowlist: "Empty allowlist — only you can interact. Add nicknames above."
    irc_auth_header: "Optional authentication (press Enter to skip each):"
    irc_server_password: "Server password (for bouncers like ZNC, leave empty if none)"
    irc_nickserv_password: "NickServ password (leave empty if none)"
    irc_sasl_password: "SASL PLAIN password (leave empty if none)"
    irc_verify_tls: "Verify TLS certificate?"
    irc_confirm: "IRC configured as %{nick}@%{server}:%{port}"
    # Webhook
    webhook_subtitle: "HTTP endpoint for custom integrations"
    webhook_setup: "Webhook Setup"
    webhook_port_prompt: "Port"
    webhook_secret_prompt: "Secret (optional, Enter to skip)"
    webhook_confirm: "Webhook on port %{port}"
    # Status badges
    badge_macos_only: "macOS only"
    badge_self_hosted: "self-hosted chat"
    badge_business_api: "Business Cloud API"
    badge_irc_tls: "IRC over TLS"
    badge_http_endpoint: "HTTP endpoint"

  # ── Step 4: Tunnel ──
  tunnel:
    intro: "A tunnel exposes your gateway to the internet securely."
    skip_hint: "Skip this if you only use CLI or local channels."
    select_prompt: "Select tunnel provider"
    skip: "Skip — local only (default)"
    cloudflare: "Cloudflare Tunnel — Zero Trust, free tier"
    tailscale: "Tailscale — private tailnet or public Funnel"
    ngrok: "ngrok — instant public URLs"
    custom: "Custom — bring your own (bore, frp, ssh, etc.)"
    cloudflare_token_hint: "Get your tunnel token from the Cloudflare Zero Trust dashboard."
    cloudflare_token_prompt: "Cloudflare tunnel token"
    tailscale_hint: "Tailscale must be installed and authenticated (tailscale up)."
    tailscale_funnel_prompt: "Use Funnel (public internet)? No = tailnet only"
    tailscale_funnel_public: "Funnel — public"
    tailscale_serve_tailnet: "Serve — tailnet only"
    ngrok_hint: "Get your auth token at https://dashboard.ngrok.com/get-started/your-authtoken"
    ngrok_token_prompt: "ngrok auth token"
    ngrok_domain_prompt: "Custom domain (optional, Enter to skip)"
    custom_hint: "Enter the command to start your tunnel."
    custom_placeholder_hint: "Use {port} and {host} as placeholders."
    custom_example: "Example: bore local {port} --to bore.pub"
    custom_prompt: "Start command"
    confirm_none: "none (local only)"
    confirm_custom: "Custom"

  # ── Step 5: Tool Mode ──
  tool_mode:
    intro: "Choose how AsteronIris connects to external apps."
    later_hint: "You can always change this later in config.toml."
    select_prompt: "Select tool mode"
    sovereign: "Sovereign (local only) — you manage API keys, full privacy (default)"
    composio: "Composio (managed OAuth) — 1000+ apps via OAuth, no raw keys shared"
    composio_title: "Composio Setup"
    composio_subtitle: "1000+ OAuth integrations (Gmail, Notion, GitHub, Slack, ...)"
    composio_url_hint: "Get your API key at: https://app.composio.dev/settings"
    composio_desc: "AsteronIris uses Composio as a tool — your core agent stays local."
    composio_key_prompt: "Composio API key (or Enter to skip)"
    composio_skipped: "Skipped — set composio.api_key in config.toml later"
    composio_confirm: "Composio: enabled (1000+ OAuth tools available)"
    sovereign_confirm: "Tool mode: Sovereign (local only) — full privacy, you own every key"
    encrypt_intro: "AsteronIris can encrypt API keys stored in config.toml."
    encrypt_desc: "A local key file protects against plaintext exposure and accidental leaks."
    encrypt_prompt: "Enable encrypted secret storage?"
    encrypt_on: "Secrets: encrypted — keys encrypted with local key file"
    encrypt_off: "Secrets: plaintext — keys stored as plaintext (not recommended)"

  # ── Step 6: Memory ──
  memory:
    intro: "Choose how AsteronIris stores and searches memories."
    later_hint: "You can always change this later in config.toml."
    select_prompt: "Select memory backend"
    sqlite: "SQLite with Vector Search (recommended) — fast, hybrid search, embeddings"
    markdown: "Markdown Files — simple, human-readable, no dependencies"
    none: "None — disable persistent memory"
    auto_save_prompt: "Auto-save conversations to memory?"
    confirm: "Memory: %{backend} (auto-save: %{auto_save})"

  # ── Step 7: Context ──
  context:
    intro: "Let's personalize your agent. You can always update these later."
    defaults_hint: "Press Enter to accept defaults."
    name_prompt: "Your name"
    tz_prompt: "Your timezone"
    tz_other: "Other (type manually)"
    tz_manual_prompt: "Enter timezone (e.g. America/New_York)"
    agent_name_prompt: "Agent name"
    style_prompt: "Communication style"
    style_direct: "Direct & concise — skip pleasantries, get to the point"
    style_friendly: "Friendly & casual — warm, human, and helpful"
    style_professional: "Professional & polished — calm, confident, and clear"
    style_expressive: "Expressive & playful — more personality + natural emojis"
    style_technical: "Technical & detailed — thorough explanations, code-first"
    style_balanced: "Balanced — adapt to the situation"
    style_custom: "Custom — write your own style guide"
    custom_style_prompt: "Custom communication style"
    confirm: "Context: %{name} | %{tz} | %{agent} | %{style}"

  # ── Step 8: Scaffold ──
  scaffold:
    created: "Created %{created} files, skipped %{skipped} existing | %{dirs} subdirectories"
    layout_header: "Workspace layout:"

  # ── Summary ──
  summary:
    ready: "AsteronIris is ready!"
    config_saved: "Configuration saved to:"
    quick_summary: "Quick summary:"
    provider: "Provider:"
    model: "Model:"
    autonomy: "Autonomy:"
    memory: "Memory:"
    channels: "Channels:"
    api_key: "API Key:"
    api_key_set: "configured"
    api_key_not_set: "not set (set via env var or config)"
    tunnel: "Tunnel:"
    tunnel_none: "none (local only)"
    composio: "Composio:"
    composio_enabled: "enabled (1000+ OAuth apps)"
    composio_disabled: "disabled (sovereign mode)"
    secrets: "Secrets:"
    secrets_encrypted: "encrypted"
    secrets_plaintext: "plaintext"
    gateway: "Gateway:"
    gateway_pairing: "pairing required (secure)"
    gateway_no_pairing: "pairing disabled"
    next_steps: "Next steps:"
    set_api_key: "Set your API key:"
    launch_channels: "Launch your channels"
    launch_channels_hint: "(connected channels → AI → reply):"
    send_message: "Send a quick message:"
    interactive_cli: "Start interactive CLI mode:"
    check_status: "Check full status:"
    happy_hacking: "Happy hacking!"

  # ── Security / memory lines in wizard ──
  security_confirm: "Security: %{level} | workspace-scoped"
  memory_confirm: "Memory: %{backend} (auto-save: %{auto_save})"

  # ── Launch prompt ──
  launch_prompt: "Launch channels now? (connected channels → AI → reply)"
  launching: "Starting channel server..."

  # ── Quick setup output ──
  quick:
    title: "Quick Setup — generating config with sensible defaults..."
    workspace: "Workspace:"
    provider: "Provider:"
    model: "Model:"
    api_key: "API Key:"
    api_key_set: "set"
    api_key_not_set: "not set (use --api-key or edit config.toml)"
    security: "Security:"
    security_value: "Supervised (workspace-scoped)"
    memory: "Memory:"
    secrets: "Secrets:"
    secrets_value: "encrypted"
    gateway: "Gateway:"
    gateway_value: "pairing required (127.0.0.1:8080)"
    tunnel: "Tunnel:"
    tunnel_value: "none (local only)"
    composio: "Composio:"
    composio_value: "disabled (sovereign mode)"
    config_saved: "Config saved:"

# ── Channels module ───────────────────────────────────────────────
channels:
  list_header: "Channels:"
  cli_always: "CLI (always available)"
  to_start: "To start channels: asteroniris channel start"
  to_check: "To check health:    asteroniris channel doctor"
  to_configure: "To configure:      asteroniris onboard"
  no_channels: "No channels configured. Run `asteroniris onboard` to set up channels."
  no_channels_doctor: "No real-time channels configured. Run `asteroniris onboard` first."
  server_title: "AsteronIris Channel Server"
  model: "Model:"
  memory: "Memory:"
  channels: "Channels:"
  skills: "Skills:"
  listening: "Listening for messages... (Ctrl+C to stop)"
  message_in: "[%{channel}] from %{sender}: %{content}"
  reply: "Reply:"
  reply_fail: "Failed to reply on %{channel}: %{error}"
  llm_error: "LLM error: %{error}"
  blocked: "External content was blocked by safety policy."
  doctor_title: "AsteronIris Channel Doctor"
  healthy: "healthy"
  unhealthy: "unhealthy (auth/config/network)"
  timed_out: "timed out (>10s)"
  webhook_hint: "Webhook   check via `asteroniris gateway` then GET /health"
  doctor_summary: "Summary: %{healthy} healthy, %{unhealthy} unhealthy, %{timeout} timed out"

# ── Gateway module ────────────────────────────────────────────────
gateway:
  listening: "AsteronIris Gateway listening on http://%{addr}"
  tunnel_starting: "Starting %{name} tunnel..."
  tunnel_active: "Tunnel active: %{url}"
  tunnel_failed: "Tunnel failed to start: %{error}"
  tunnel_fallback: "Falling back to local-only mode."
  public_url: "Public URL: %{url}"
  route_pair: "POST /pair      — pair a new client (X-Pairing-Code header)"
  route_webhook: "POST /webhook   — {\"message\": \"your prompt\"}"
  route_whatsapp_get: "GET  /whatsapp  — Meta webhook verification"
  route_whatsapp_post: "POST /whatsapp  — WhatsApp message webhook"
  route_health: "GET  /health    — health check"
  pairing_required: "PAIRING REQUIRED — use this one-time code:"
  pairing_send: "Send: POST /pair with header X-Pairing-Code: %{code}"
  pairing_active: "Pairing: ACTIVE (bearer token required)"
  pairing_disabled: "Pairing: DISABLED (all requests accepted)"
  webhook_secret_enabled: "Webhook secret: ENABLED"
  stop_hint: "Press Ctrl+C to stop."

# ── Doctor module ─────────────────────────────────────────────────
doctor:
  title: "AsteronIris Doctor"
  state_file: "State file: %{path}"
  state_not_found: "daemon state file not found: %{path}"
  start_hint: "Start daemon with: asteroniris daemon"
  heartbeat_fresh: "daemon heartbeat fresh (%{age}s ago)"
  heartbeat_stale: "daemon heartbeat stale (%{age}s ago)"
  timestamp_invalid: "invalid daemon timestamp: %{value}"
  scheduler_healthy: "scheduler healthy (last ok %{age}s ago)"
  scheduler_unhealthy: "scheduler unhealthy/stale (status_ok=%{ok}, age=%{age}s)"
  scheduler_missing: "scheduler component missing"
  channel_fresh: "%{name} fresh (last ok %{age}s ago)"
  channel_stale: "%{name} stale/unhealthy (status_ok=%{ok}, age=%{age}s)"
  no_channels: "no channel components tracked in state yet"
  channel_summary: "Channel summary: %{total} total, %{stale} stale"
  autonomy_governance: "Autonomy governance:"
  memory_rollout: "Memory rollout:"

# ── Status module ─────────────────────────────────────────────────
status:
  title: "AsteronIris Status"
  version: "Version:"
  workspace: "Workspace:"
  config: "Config:"
  provider: "Provider:"
  model: "Model:"
  observability: "Observability:"
  autonomy: "Autonomy:"
  external_actions: "External actions:"
  temperature_band: "Temperature band:"
  rollout_stage: "Rollout stage:"
  rollout_policy: "Rollout policy:"
  verify_repair: "Verify/repair caps:"
  autonomy_metrics: "Autonomy lifecycle metrics:"
  runtime: "Runtime:"
  heartbeat: "Heartbeat:"
  memory: "Memory:"
  memory_rollout: "Memory rollout:"
  memory_metrics: "Memory lifecycle metrics:"
  security: "Security:"
  workspace_only: "Workspace only:"
  allowed_commands: "Allowed commands:"
  max_actions: "Max actions/hour:"
  max_cost: "Max cost/day:"
  channels: "Channels:"
  cli_always: "CLI:      always"

# ── Daemon module ─────────────────────────────────────────────────
daemon:
  started: "AsteronIris daemon started"
  gateway_addr: "Gateway:  http://%{host}:%{port}"
  components: "Components: gateway, channels, heartbeat, scheduler"
  stop_hint: "Ctrl+C to stop"

# ── Common ────────────────────────────────────────────────────────
common:
  on: "on"
  off: "off"
  enabled: "enabled"
  disabled: "disabled"
  supported: "supported"
  degraded: "degraded"
  unsupported: "unsupported"
  unknown: "unknown"
  confirmed: "configured"
  not_configured: "not configured"
  auto_save_on: "on"
  auto_save_off: "off"
  every_min: "every %{n}min"
